--[[
	AntiExploit.lua
	Comprehensive anti-exploit system

	Features:
	- Speed hack detection
	- Teleport detection
	- Fly/noclip detection
	- ESP detection
	- Script injection detection
	- Humanoid tampering detection
	- Tool duplication detection
	- Remote spam detection

	Created: 2025-12-02
--]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local ServerScriptService = game:GetService("ServerScriptService")

-- Safe require of utilities
local WebhookLogger = nil
local ServiceLocator = nil
pcall(function()
	WebhookLogger = require(ServerScriptService.Utilities.WebhookLogger)
	ServiceLocator = require(ServerScriptService.Utilities.ServiceLocator)
end)

local AntiExploit = {}
AntiExploit.Enabled = true

-- Configuration
local CONFIG = {
	-- Movement
	MaxWalkSpeed = 20,
	MaxJumpPower = 60,
	MaxTeleportDistance = 50,
	MaxVerticalSpeed = 100,

	-- Detection thresholds
	SpeedViolationThreshold = 3,
	TeleportViolationThreshold = 2,
	FlyViolationThreshold = 5,

	-- Timing
	CheckInterval = 0.1,
	PositionHistorySize = 10,

	-- Actions
	AutoKick = true,
	AutoBan = true,
	BanDuration = 86400, -- 24 hours

	-- Physics
	MaxFallSpeed = 200,
	NoClipCheckDistance = 5,

	-- Memory
	MaxClientMemory = 1000, -- MB
	MaxRemoteCallsPerSecond = 50
}

-- Player tracking
local playerData = {}
local violations = {}
local detectionStats = {}

-- ============================================================================
-- PLAYER DATA MANAGEMENT
-- ============================================================================

local PlayerTracker = {}
PlayerTracker.__index = PlayerTracker

function PlayerTracker.new(player: Player)
	local self = setmetatable({}, PlayerTracker)

	self.Player = player
	self.Character = player.Character
	self.Humanoid = self.Character and self.Character:FindFirstChild("Humanoid")
	self.RootPart = self.Character and self.Character:FindFirstChild("HumanoidRootPart")

	self.PositionHistory = {}
	self.VelocityHistory = {}
	self.LastPosition = nil
	self.LastCheck = tick()
	self.RespawnTime = tick() -- Track when character spawned for teleport validation
	self.InAir = false
	self.AirTime = 0
	self.LastGroundY = 0

	self.Violations = {
		Speed = 0,
		Teleport = 0,
		Fly = 0,
		NoClip = 0,
		Humanoid = 0,
		Memory = 0
	}

	self.Stats = {
		MaxSpeed = 0,
		MaxJump = 0,
		TotalDistance = 0,
		CheckCount = 0
	}

	return self
end

function PlayerTracker:Update()
	if not self.Character or not self.RootPart then
		return
	end

	local now = tick()
	local deltaTime = now - self.LastCheck
	self.LastCheck = now

	local currentPosition = self.RootPart.Position

	-- Store position history
	table.insert(self.PositionHistory, {
		Position = currentPosition,
		Time = now
	})

	-- Limit history size
	while #self.PositionHistory > CONFIG.PositionHistorySize do
		table.remove(self.PositionHistory, 1)
	end

	-- Perform checks if we have previous position
	if self.LastPosition then
		self:CheckSpeed(currentPosition, deltaTime)
		self:CheckTeleport(currentPosition)
		self:CheckFlying(currentPosition, deltaTime)
		self:CheckNoClip(currentPosition)
	end

	self.LastPosition = currentPosition
	self.Stats.CheckCount = self.Stats.CheckCount + 1
end

-- ============================================================================
-- SPEED HACK DETECTION
-- ============================================================================

function PlayerTracker:CheckSpeed(currentPosition: Vector3, deltaTime: number)
	if deltaTime <= 0 then
		return
	end

	local distance = (currentPosition - self.LastPosition).Magnitude
	local speed = distance / deltaTime

	-- Update max speed stat
	self.Stats.MaxSpeed = math.max(self.Stats.MaxSpeed, speed)
	self.Stats.TotalDistance = self.Stats.TotalDistance + distance

	-- Get expected max speed
	local maxSpeed = CONFIG.MaxWalkSpeed
	if self.Humanoid then
		maxSpeed = math.max(maxSpeed, self.Humanoid.WalkSpeed + 5) -- Small buffer
	end

	-- Account for falling
	if currentPosition.Y < self.LastPosition.Y then
		maxSpeed = math.max(maxSpeed, CONFIG.MaxFallSpeed)
	end

	-- Check for speed violation
	if speed > maxSpeed then
		self.Violations.Speed = self.Violations.Speed + 1

		warn(string.format("[AntiExploit] Speed violation: %s (%.1f studs/s, max: %.1f)",
			self.Player.Name, speed, maxSpeed))

		if self.Violations.Speed >= CONFIG.SpeedViolationThreshold then
			self:HandleViolation("SPEED_HACK", {
				Speed = speed,
				MaxSpeed = maxSpeed,
				Position = currentPosition
			})
		end
	else
		-- Decay violations
		self.Violations.Speed = math.max(0, self.Violations.Speed - 0.1)
	end
end

-- ============================================================================
-- TELEPORT DETECTION
-- ============================================================================

function PlayerTracker:CheckTeleport(currentPosition: Vector3)
	local distance = (currentPosition - self.LastPosition).Magnitude

	-- Check if distance is unreasonably large
	if distance > CONFIG.MaxTeleportDistance then
		-- Check if it's a legitimate teleport (respawn, etc.)
		if not self:IsLegitTeleport(currentPosition) then
			self.Violations.Teleport = self.Violations.Teleport + 1

			warn(string.format("[AntiExploit] Teleport violation: %s (%.1f studs)",
				self.Player.Name, distance))

			if self.Violations.Teleport >= CONFIG.TeleportViolationThreshold then
				self:HandleViolation("TELEPORT_HACK", {
					Distance = distance,
					FromPosition = self.LastPosition,
					ToPosition = currentPosition
				})
			end
		end
	else
		self.Violations.Teleport = math.max(0, self.Violations.Teleport - 0.1)
	end
end

function PlayerTracker:IsLegitTeleport(position: Vector3): boolean
	-- Check if near spawn
	local spawnLocation = Workspace:FindFirstChild("SpawnLocation")
	if spawnLocation then
		local spawnDistance = (position - spawnLocation.Position).Magnitude
		if spawnDistance < 20 then
			return true
		end
	end

	-- Check if character was just loaded
	if self.Stats.CheckCount < 5 then
		return true
	end

	-- Check if player recently respawned (within grace period)
	-- SECURITY: Reduced grace period from 3s to 1.5s to limit exploit window
	local now = tick()
	if self.RespawnTime and (now - self.RespawnTime) < 1.5 then
		return true
	end

	-- Check if player teleported to a checkpoint (common game mechanic)
	-- Look for any CheckpointPart nearby
	local checkpoints = Workspace:FindFirstChild("Checkpoints")
	if checkpoints then
		for _, checkpoint in ipairs(checkpoints:GetChildren()) do
			if checkpoint:IsA("BasePart") then
				local dist = (position - checkpoint.Position).Magnitude
				if dist < 20 then
					return true
				end
			end
		end
	end

	return false
end

-- ============================================================================
-- FLY/NOCLIP DETECTION
-- ============================================================================

function PlayerTracker:CheckFlying(currentPosition: Vector3, deltaTime: number)
	-- Check if player is in air
	local raycast = Workspace:Raycast(
		currentPosition,
		Vector3.new(0, -10, 0),
		RaycastParams.new()
	)

	local isGrounded = raycast ~= nil

	if not isGrounded then
		self.InAir = true
		self.AirTime = self.AirTime + deltaTime

		-- Check vertical movement
		local verticalSpeed = (currentPosition.Y - self.LastPosition.Y) / deltaTime

		-- Check for sustained flight
		if self.AirTime > 2 then
			-- Check if moving up while in air for too long
			if verticalSpeed > 5 then
				self.Violations.Fly = self.Violations.Fly + 1

				if self.Violations.Fly >= CONFIG.FlyViolationThreshold then
					self:HandleViolation("FLY_HACK", {
						AirTime = self.AirTime,
						VerticalSpeed = verticalSpeed,
						Position = currentPosition
					})
				end
			end

			-- Check if hovering
			if math.abs(verticalSpeed) < 1 and self.AirTime > 5 then
				self.Violations.Fly = self.Violations.Fly + 1
			end
		end
	else
		self.InAir = false
		self.AirTime = 0
		self.LastGroundY = currentPosition.Y
		self.Violations.Fly = math.max(0, self.Violations.Fly - 0.2)
	end
end

function PlayerTracker:CheckNoClip(currentPosition: Vector3)
	if not self.LastPosition then
		return
	end

	-- Cast ray between positions
	local direction = currentPosition - self.LastPosition
	local raycast = Workspace:Raycast(
		self.LastPosition,
		direction,
		RaycastParams.new()
	)

	-- Check if ray hit something
	if raycast and raycast.Instance then
		-- Check if hit object is solid
		if raycast.Instance.CanCollide then
			-- Player passed through solid object
			self.Violations.NoClip = self.Violations.NoClip + 1

			warn(string.format("[AntiExploit] NoClip violation: %s",
				self.Player.Name))

			if self.Violations.NoClip >= 3 then
				self:HandleViolation("NOCLIP_HACK", {
					FromPosition = self.LastPosition,
					ToPosition = currentPosition,
					BlockedBy = raycast.Instance:GetFullName()
				})
			end
		end
	else
		self.Violations.NoClip = math.max(0, self.Violations.NoClip - 0.1)
	end
end

-- ============================================================================
-- HUMANOID TAMPERING DETECTION
-- ============================================================================

function PlayerTracker:CheckHumanoid()
	if not self.Humanoid then
		return
	end

	local violations = false

	-- Check WalkSpeed
	if self.Humanoid.WalkSpeed > CONFIG.MaxWalkSpeed then
		warn(string.format("[AntiExploit] WalkSpeed tampering: %s (%.1f)",
			self.Player.Name, self.Humanoid.WalkSpeed))
		self.Humanoid.WalkSpeed = 16
		violations = true
	end

	-- Check JumpPower
	if self.Humanoid.JumpPower > CONFIG.MaxJumpPower then
		warn(string.format("[AntiExploit] JumpPower tampering: %s (%.1f)",
			self.Player.Name, self.Humanoid.JumpPower))
		self.Humanoid.JumpPower = 50
		violations = true
	end

	-- Check MaxHealth
	if self.Humanoid.MaxHealth > 100 then
		warn(string.format("[AntiExploit] MaxHealth tampering: %s (%.1f)",
			self.Player.Name, self.Humanoid.MaxHealth))
		self.Humanoid.MaxHealth = 100
		violations = true
	end

	-- Check HipHeight
	if self.Humanoid.HipHeight > 5 then
		warn(string.format("[AntiExploit] HipHeight tampering: %s (%.1f)",
			self.Player.Name, self.Humanoid.HipHeight))
		violations = true
	end

	if violations then
		self.Violations.Humanoid = self.Violations.Humanoid + 1

		if self.Violations.Humanoid >= 3 then
			self:HandleViolation("HUMANOID_TAMPERING", {
				WalkSpeed = self.Humanoid.WalkSpeed,
				JumpPower = self.Humanoid.JumpPower,
				MaxHealth = self.Humanoid.MaxHealth
			})
		end
	else
		self.Violations.Humanoid = math.max(0, self.Violations.Humanoid - 0.1)
	end
end

-- ============================================================================
-- VIOLATION HANDLING
-- ============================================================================

function PlayerTracker:HandleViolation(violationType: string, data: {})
	warn(string.format("[AntiExploit] VIOLATION: %s by %s",
		violationType, self.Player.Name))

	-- Record violation
	if not violations[self.Player.UserId] then
		violations[self.Player.UserId] = {}
	end

	table.insert(violations[self.Player.UserId], {
		Type = violationType,
		Data = data,
		Timestamp = tick()
	})

	-- Update stats
	detectionStats[violationType] = (detectionStats[violationType] or 0) + 1

	-- Log to webhook
	if WebhookLogger then
		WebhookLogger.LogExploitDetection(self.Player, violationType, data)
	end

	-- Report to monitoring systems
	local BugReporter = ServiceLocator and ServiceLocator.Get("BugReporter")
	if BugReporter and BugReporter.ReportBug then
		BugReporter.ReportBug("EXPLOIT",
			string.format("Exploit detected: %s", violationType),
			{
				Player = self.Player.Name,
				UserId = self.Player.UserId,
				ViolationType = violationType,
				ViolationData = data
			},
			self.Player)
	end

	-- Take action
	local SecurityManager = ServiceLocator and ServiceLocator.Get("SecurityManager")
	if SecurityManager and SecurityManager.BanPlayer then
		if CONFIG.AutoBan then
			SecurityManager.BanPlayer(self.Player,
				string.format("Anti-Exploit: %s", violationType),
				CONFIG.BanDuration)
		elseif CONFIG.AutoKick then
			self.Player:Kick(string.format("Exploiting detected: %s", violationType))
		end
	elseif CONFIG.AutoKick then
		self.Player:Kick(string.format("Exploiting detected: %s", violationType))
	end

	-- Revert position for movement exploits
	if violationType == "TELEPORT_HACK" or violationType == "SPEED_HACK" then
		if #self.PositionHistory > 2 then
			local safePosition = self.PositionHistory[#self.PositionHistory - 2].Position
			self.RootPart.CFrame = CFrame.new(safePosition)
		end
	end
end

-- ============================================================================
-- TOOL/ITEM DUPLICATION DETECTION
-- ============================================================================

function AntiExploit.CheckToolDuplication(player: Player)
	local character = player.Character
	if not character then
		return
	end

	local backpack = player.Backpack
	local tools = {}

	-- Count tools in backpack
	for _, tool in ipairs(backpack:GetChildren()) do
		if tool:IsA("Tool") then
			tools[tool.Name] = (tools[tool.Name] or 0) + 1
		end
	end

	-- Count tools in character
	for _, tool in ipairs(character:GetChildren()) do
		if tool:IsA("Tool") then
			tools[tool.Name] = (tools[tool.Name] or 0) + 1
		end
	end

	-- Check for duplicates
	for toolName, count in pairs(tools) do
		if count > 1 then
			warn(string.format("[AntiExploit] Tool duplication: %s has %d x %s",
				player.Name, count, toolName))

			-- Remove duplicates
			local found = 0
			for _, tool in ipairs(backpack:GetChildren()) do
				if tool:IsA("Tool") and tool.Name == toolName then
					found = found + 1
					if found > 1 then
						tool:Destroy()
					end
				end
			end
		end
	end
end

-- ============================================================================
-- MEMORY MONITORING
-- ============================================================================

function AntiExploit.CheckClientMemory(player: Player)
	-- This would require client-side reporting
	-- For now, we'll monitor server-side indicators

	local character = player.Character
	if not character then
		return
	end

	-- Count parts in character
	local partCount = 0
	for _, desc in ipairs(character:GetDescendants()) do
		if desc:IsA("BasePart") then
			partCount = partCount + 1
		end
	end

	-- Check for excessive parts (potential lag exploit)
	if partCount > 100 then
		warn(string.format("[AntiExploit] Excessive parts in character: %s (%d parts)",
			player.Name, partCount))

		-- Clean up extra parts
		local normalParts = 15 -- Typical character part count
		local removed = 0
		for _, desc in ipairs(character:GetDescendants()) do
			if desc:IsA("BasePart") and removed < partCount - normalParts then
				if not desc.Parent:IsA("Humanoid") and desc.Name ~= "HumanoidRootPart" then
					desc:Destroy()
					removed = removed + 1
				end
			end
		end
	end
end

-- ============================================================================
-- ESP DETECTION
-- ============================================================================

function AntiExploit.CheckESP(player: Player)
	-- Check for common ESP indicators
	local character = player.Character
	if not character then
		return
	end

	-- Check for added GUIs to other players
	for _, otherPlayer in ipairs(Players:GetPlayers()) do
		if otherPlayer ~= player and otherPlayer.Character then
			for _, desc in ipairs(otherPlayer.Character:GetDescendants()) do
				if desc:IsA("BillboardGui") or desc:IsA("SurfaceGui") then
					-- Check if created by the suspected player
					local creator = desc:GetAttribute("Creator")
					if creator == player.UserId then
						warn(string.format("[AntiExploit] ESP detected: %s added GUI to %s",
							player.Name, otherPlayer.Name))
						desc:Destroy()
					end
				end
			end
		end
	end
end

-- ============================================================================
-- MAIN LOOP
-- ============================================================================

function AntiExploit.StartMonitoring()
	-- Main detection loop
	RunService.Heartbeat:Connect(function()
		if not AntiExploit.Enabled then
			return
		end

		for _, player in ipairs(Players:GetPlayers()) do
			local tracker = playerData[player]
			if tracker then
				tracker:Update()
			end
		end
	end)

	-- Slower checks
	task.spawn(function()
		while AntiExploit.Enabled do
			task.wait(1)

			for _, player in ipairs(Players:GetPlayers()) do
				local tracker = playerData[player]
				if tracker then
					tracker:CheckHumanoid()
					AntiExploit.CheckToolDuplication(player)
					AntiExploit.CheckClientMemory(player)
				end
			end
		end
	end)

	-- ESP check
	task.spawn(function()
		while AntiExploit.Enabled do
			task.wait(5)

			for _, player in ipairs(Players:GetPlayers()) do
				AntiExploit.CheckESP(player)
			end
		end
	end)
end

-- ============================================================================
-- PLAYER MANAGEMENT
-- ============================================================================

local function onCharacterAdded(character: Model)
	local player = Players:GetPlayerFromCharacter(character)
	if not player then
		return
	end

	-- Create new tracker
	playerData[player] = PlayerTracker.new(player)

	-- Set respawn time for teleport validation grace period
	if playerData[player] then
		playerData[player].RespawnTime = tick()

		-- Reset violations on respawn
		for key in pairs(playerData[player].Violations) do
			playerData[player].Violations[key] = 0
		end
	end
end

local function onPlayerAdded(player: Player)
	-- Wait for character
	player.CharacterAdded:Connect(onCharacterAdded)

	if player.Character then
		onCharacterAdded(player.Character)
	end
end

local function onPlayerRemoving(player: Player)
	playerData[player] = nil
end

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Handle existing players
for _, player in ipairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end

-- ============================================================================
-- PUBLIC API
-- ============================================================================

function AntiExploit.GetViolations(player: Player): {}?
	return violations[player.UserId]
end

function AntiExploit.ClearViolations(player: Player)
	violations[player.UserId] = nil
	if playerData[player] then
		for key in pairs(playerData[player].Violations) do
			playerData[player].Violations[key] = 0
		end
	end
end

function AntiExploit.GetStatistics(): {}
	local stats = {
		TotalDetections = 0,
		DetectionsByType = detectionStats,
		ActivePlayers = 0,
		CurrentViolators = {}
	}

	for _, tracker in pairs(playerData) do
		stats.ActivePlayers = stats.ActivePlayers + 1

		local hasViolations = false
		for _, count in pairs(tracker.Violations) do
			if count > 0 then
				hasViolations = true
				break
			end
		end

		if hasViolations then
			table.insert(stats.CurrentViolators, {
				Player = tracker.Player.Name,
				Violations = tracker.Violations
			})
		end
	end

	for _, count in pairs(detectionStats) do
		stats.TotalDetections = stats.TotalDetections + count
	end

	return stats
end

function AntiExploit.SetConfig(key: string, value: any)
	if CONFIG[key] ~= nil then
		CONFIG[key] = value
		print(string.format("[AntiExploit] Config updated: %s = %s", key, tostring(value)))
	end
end

-- ============================================================================
-- INITIALIZATION
-- ============================================================================

function AntiExploit.Initialize()
	print("[AntiExploit] Initializing anti-exploit system...")

	-- Start monitoring
	AntiExploit.StartMonitoring()

	-- Register with ServiceLocator
	if ServiceLocator then
		ServiceLocator.Register("AntiExploit", AntiExploit)
	end

	print("[AntiExploit] âœ… Anti-exploit system ready")
end

-- Auto-initialize
task.spawn(function()
	task.wait(1)
	AntiExploit.Initialize()
end)

-- ============================================================================
-- EXPORT
-- ============================================================================

return AntiExploit